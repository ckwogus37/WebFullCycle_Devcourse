# <Node.js 및 Express.js를 사용한 서버 개발 실습 (2)>

# Part 5. Express와 천천히 친해지기

## Chapter 1. Post method와 Postman

### 6. 전체 조회 기능 추가 (feat. 구글링)

- youtuber-demo.js 코드의 전체 조회 기능 부분
    
    ```jsx
    // ...
    // 등록되어있는 모든 유튜버 조회 기능
    app.get('/youtubers', (req,res)=>{
        let youtubers = {}  // 각 유튜버의 정보들을 담을 객체 선언
        db.forEach((value, key)=>{  // Map객체에 들어있는 값들을 하나씩 확인
            youtubers[key] = value
        })
        res.json(youtubers);
    })
    ```
    
    - Map객체와 forEach함수를 통해 등록되어있는 모든 유튜버의 정보를 조회하는 기능까지 고도화를 완료하였다.
    - 다음은 등록되어있는 유튜버를 삭제하는 기능을 고도화할 차례이다.

## Chapter 2. DELETE method

### 1. 등록되어있는 유튜버 개별 삭제 기능 추가

- youtuber-demo.js 코드의 기존 유튜버 삭제 부분
    
    ```jsx
    // ...
    
    // 기존 유튜버 삭제 REST API 설계
    app.delete('/youtubers/:id',(req,res)=>{
        let{id} = req.params
        id = parseInt(id)
    
        if(db.get(id)==undefined){
            res.json({
                "message" : `요청하신 ${id}번은 없는 유튜버입니다.`
            })
        }else{
    		    let {channelTitle} = db.get(id)
            db.delete(id)
            res.json({
                "message" : `${channelTitle}님, 아쉽지만 다음에 뵙겠습니다.`
            })
        }
    })
    ```
    
    - DELETE method를 이용하여 유튜버 삭제 기능을 구현했다.
    - 개별 유튜버 조회때 처럼, req의 id값을 받아와 Map객체(db)에서 id값을 key값으로 가지고있는 데이터를 삭제할 수 있게되었다.

### 2. 등록되어있는 유튜버 전체 삭제 기능

- youtuber-demo.js 코드의 전체 유튜버 삭제 부분
    
    ```jsx
    // ...
    // 전체 유튜버 삭제 REST API 설계
    app.delete('/youtubers',(req,res)=>{
    
        let msg = "";
    
        //현재 둥록된 유튜버 현황 확인 필요
        // db에 값이 1개 이상이면, 전체 삭제
        if(db.size >= 1){ 
            db.clear()
            msg = "전체 유튜버가 삭제되었습니다."
        }else{ 
            msg = "삭제할 유튜버가 없습니다."
        }
    
        res.json({
            message : msg
        })
    
    })
    ```
    
    - Map객체의 모든 데이터를 삭제하는 `Map객체.clear()`함수 사용하여 전체 유튜버 삭제 기능 구현
    - Map객체의 property인 `Map객체.size` 변수로 Map객체 크기 확인 가능

## Chapter 3. PUT method

### 1. 개별 유튜버 수정 기능 추가

- youtuber-demo.js 코드의 개별 유튜버 정보 수정 부분
    
    ```jsx
    // 개별 유튜버 정보 수정 REST API 설계
    app.put('/youtubers/:id',(req,res)=>{
        let {id} = req.params
        id = parseInt(id)
        let msg = ""
        let youtuber_inf = db.get(id)
    
    		// 예외처리
        if(youtuber_inf == undefined){
            msg = `요청하신 ${id}번은 없는 유튜버입니다.`
        }else{
            const oldTitle = youtuber_inf.channelTitle
            // HTTP BODY를 통해 수정할 값 받아오기
            const newTitle = req.body.channelTitle
    
            youtuber_inf.channelTitle = newTitle
            db.set(id,youtuber_inf)
    
            msg = `${oldTitle}님 채널명이 ${newTitle}로 수정되었습니다.`
        }
    
        res.json({
            message : msg
        })
    })
    ```
    
    - 기존에 등록되있던 정보를 수정하기 위해선, 어떤 값으로 수정할지 사용자로부터 정보를 받아와야 합니다.
    - 그래서 초반에 유튜버 등록 기능을 구현할 때, HTTP 프로토콜의 BODY부분에 데이터를 숨겨가지고 온것을 이용하여 수정할 값을 BODY에 받아와 사용합니다. ( `req.body` )
    - 이후, 수정할 유튜버의 Map객체 property에서 수정할 value에 새로운 값을 저장합니다.
    - 마지막으로 Map객체의 set()함수를 이용하여 다시 property를 저장하여 유튜버 정보 수정을 완료합니다.

---

## Chapter 4. HTTP 상태 코드

### 1. HTTP 안에 작성되어서 들어가는 “상태”

- **조회/수정/삭제 성공(GET, PUT, DELETE) : 200**
- **등록 성공(POST) : 201**
- **찾는 페이지 없음 (URL에 맞는 API 없음) : 404**
- 서버가 죽었을 때 (사실은 서버가 크리티컬한 오류를 맞았을 때) : 500

---

## Chapter 5. 알아두면 편한 JavaScript 함수

### 1. forEach()

- “ 기능이 향상된 for문 “ 이라고 불린다.
- forEach() 예시 코드
    
    ```jsx
    const arr = [1,2,3,4,5]
    
    // 배열(또는 객체)에서 요소를 하나 꺼낸 다음
    // 매개변수에 그 요소를 전달하여 호출되는 콜백함수
    arr.forEach((a,b,c)=>{
             // value, index, 배열 전체값
        console.log(`a : ${a}, b : ${b}, c : ${c}`)
    })
    
    // Map(객체)과 forEach의 만남
    let map = new Map();
    map.set(7,'seven')
    map.set(9,'nine')
    map.set(8,'eight')
    
    arr.forEach((a,b,c)=>{
            // value, key, 객체 전체값
        console.log(`a : ${a}, b : ${b}, c : ${c}`)
    })
    ```
    

### 2. map()

- return 부분이 다른 forEach() 함수!
- map() 예시 코드
    
    ```jsx
    // map 함수 ( HTTP 프로토콜의 method가 아니다. )
    
    // map vs forEach
    // return에 차이가 있다!
    
    const arr = [1,2,3,4,5]
    
    const foreachArr = arr.forEach((a,b,c)=>{
        return a * 2
    })
    console.log(arr)
    
    const mapArr = arr.map((a,b,c)=>{
        return a * 2
    })
    console.log(arr)
    
    console.log(`forEach로 return하면 ${foreachArr},
                map으로 return하면 ${mapArr}`)
                
    // 출력 
    // [ 1, 2, 3, 4, 5 ]
    // [ 1, 2, 3, 4, 5 ]
    // forEach로 return하면 undefined,
    // map으로 return하면 2,4,6,8,10
    ```
    
    - forEach()함수는 return값이 없다.
    - map()함수는 return값이 존재한다.
        - return값은 기존 배열의 value들을 가지고 계산하여 그 결과값으로 이루어진 배열이다.
    - 그렇다면 Map객체에서 forEach()는 사용했는데 map()도 사용할 수 있을까?
        - **대답은 No! map()함수는 배열에서만 사용이 가능하다!**
        - 하지만 객체를 배열로 바꾸어준다면 그때는 map()함수를 사용할 수 있다.
        - 객체를 배열로 전환하는 함수는 3가지가 있다.
            - Object.key() = 객체의 key값만으로 이루어진 배열 반환
            - Object.value() = 객체의 valuer값만으로 이루어진 배열 반환
            - Object.entries() = 객체의 key-value 값의 배열로 이루어진 배열 반환
        - 다음은 위의 3가지 코드에 대한 예시 코드이다
            
            ```jsx
            const 객체 = { a: 1, b: 2, c: 3 };
            
            // 키에 대해 map 함수 사용
            const 키배열 = Object.keys(객체).map(key => key);
            console.log(키배열);// ['a', 'b', 'c']// 값에 대해 map 함수 사용
            
            const 값배열 = Object.values(객체).map(value => value * 2);
            console.log(값배열);// [2, 4, 6]// 키-값 쌍에 대해 map 함수 사용
            
            const 새로운배열 = Object.entries(객체).map(([key, value]) => {
              return [key, value * 2];
            });
            console.log(새로운배열);// [['a', 2], ['b', 4], ['c', 6]]
            ```
            

---

## Chapter 6. 리팩토링

### 1. 리팩토링이란?

- 소프트웨어 코드 내부(구조)를 변경하는 것
    - 코드를 더욱 이해하기 쉽게
    - 코드의 성능을 향상
    - 코드의 안전성을 향상
    
    **→ Clean Code를 만들기 위한 리팩토링이 필요하다!**
    

### 2. 리팩토링은 언제 해야할까?

- 에러(문제점)이 n회 발견되었을 때, 리팩토링을 해야한다.
- 리팩토링을 하면서, 에러(문제점)을 발견할 수 있다.
- 코드 리뷰할 때, 리팩토링 할 수 있다.

 ❗  **기능을 추가하기 전에 리팩토링을 해야한다.**

**그렇다면 리팩토링을 하지 말아야할 타이밍은?**

🤯 **배포, 운영 직전** 🤯 **에는 절대로 코드 수정이 일어나선 안된다!!!!
→ 코드 수정이 일어나면 다시 테스트를 해봐야하기에 시간이 부족하다!**